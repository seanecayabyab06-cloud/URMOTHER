{"mode":"Text","hardwareTarget":"brain","textContent":"#include \"vex.h\"\nusing namespace vex;\n\n// brain motors \nmotor RightMotor1 = motor(PORT1, ratio36_1, true);\nmotor RightMotor2 = motor(PORT2, ratio36_1, false);\n\nmotor LeftMotor1 = motor(PORT3, ratio36_1, false);\nmotor LeftMotor2 = motor(PORT4, ratio36_1, true);\n\n\n// INTAKE MOTOR\nmotor LeftIntake = motor(PORT6, ratio36_1, true);\nmotor RightIntake = motor(PORT5, ratio36_1, true);\n\n// BELT CHAIN + ENTRY INTAKE\nmotor BeltAndEntry = motor(PORT7, ratio36_1, false);\n\n// OUTAKE MOTOR\nmotor OutakeMotor = motor(PORT8, ratio36_1, false);\n\n// inertial sensor\ninertial Inertial = inertial (PORT9);\n\n\n// motor groups\n\nvex::motor_group LeftGroup(LeftMotor1, LeftMotor2);\nvex::motor_group RightGroup(RightMotor1, RightMotor2);\nvex::motor_group IntakeGroup(LeftIntake, RightIntake);\n\n#include \"vex.h\"\n\nusing namespace vex;\n\ncompetition Competition;\n\n// ================= CONSTANTS =================\n\ndouble wheelDiameter = 82.55;\ndouble circumference = M_PI * wheelDiameter;\nstatic double kP = 0.9;\n\n// ================= RAM =================\n\nvoid RAM (int repetitions, double forwardDeg, double reverseDeg,\n          double driveSpeed, double intakeSpeed, double beltSpeed){\n\nfor(int i = 0; i < repetitions; i++){\n\n    // -------- FORWARD --------\n    LeftGroup.resetPosition();\n    RightGroup.resetPosition();\n    Inertial.setRotation(0, degrees);\n\n    while(true){\n\n        double avg = (fabs(LeftGroup.position(degrees)) +\n                     fabs(RightGroup.position(degrees))) / 2.0;\n\n        if (avg >= forwardDeg) break;\n\n        double heading = Inertial.rotation();\n        double correction = heading * kP;\n\n        LeftGroup.spin(forward, driveSpeed - correction, percent);\n        RightGroup.spin(forward, driveSpeed + correction, percent);\n\n        // YOUR EXACT INTAKE DIRECTIONS\n        LeftIntake.spin(reverse, intakeSpeed, percent); \n        RightIntake.spin(forward, intakeSpeed, percent);\n        BeltAndEntry.spin(forward, beltSpeed, percent);\n\n        wait(10, msec);\n    }\n\n    // -------- REVERSE --------\n    LeftGroup.resetPosition();\n    RightGroup.resetPosition();\n\n    while(true){\n\n        double avg = (fabs(LeftGroup.position(degrees)) +\n                     fabs(RightGroup.position(degrees))) / 2.0;\n\n        if (avg >= reverseDeg) break;\n\n        double heading = Inertial.rotation();\n        double correction = heading * kP;\n\n        LeftGroup.spin(reverse, driveSpeed - correction, percent);\n        RightGroup.spin(reverse, driveSpeed + correction, percent);\n\n        // SAME INTAKE DIRECTIONS\n        LeftIntake.spin(reverse, intakeSpeed, percent);\n        RightIntake.spin(forward, intakeSpeed, percent);\n        BeltAndEntry.spin(forward, beltSpeed, percent);\n\n        wait(10, msec);\n    }\n}\n\nLeftGroup.stop(brake);\nRightGroup.stop(brake);\nIntakeGroup.stop(brake);\nBeltAndEntry.stop(brake);\n}\n\n// ================= DRIVE FORWARD =================\n\nvoid DriveForward (double distance, double speed){\n\n    LeftGroup.resetPosition();\n    RightGroup.resetPosition();\n    Inertial.setRotation(0, degrees);\n\n    double targetDeg = (distance / circumference) * 360.0;\n    double tol = 5;\n\n    while(true){\n\n        double avg = (LeftGroup.position(degrees) +\n                     RightGroup.position(degrees)) / 2.0;\n\n        double errorDist = targetDeg - avg;\n\n        if (fabs(errorDist) < tol) break;\n\n        double headingError = 0 - Inertial.rotation();\n        double correction = 0.4 * headingError;\n\n        double drivePower = (errorDist > 0) ? speed : -speed;\n\n        LeftGroup.spin(forward, drivePower + correction, percent);\n        RightGroup.spin(forward, drivePower - correction, percent);\n\n        wait(10,msec);\n    }\n\n    LeftGroup.stop(brake);\n    RightGroup.stop(brake);\n}\n\nvoid Intake (double speed, double BeltSpeed){\n  IntakeGroup.spin(forward, speed, percent);\n  BeltAndEntry.spin(forward, BeltSpeed, percent);\n}\n\n// ================= RIGHT TURN =================\n\nvoid RightTurn (double angle, double speed){\n\n    Inertial.setRotation(0, degrees);\n\n    while(true){\n\n        double error = angle - Inertial.rotation();\n\n        if(fabs(error) < 1.0) break;\n\n        double correction = 0.6 * error;\n\n        if (correction > speed) correction = speed;\n        if (correction < -speed) correction = -speed;\n\n        LeftGroup.spin(reverse, correction, percent);\n        RightGroup.spin(forward, correction, percent);\n\n        wait(10, msec);\n    }\n\n    LeftGroup.stop(brake);\n    RightGroup.stop(brake);\n}\n// ================= LEFT TURN =================\nvoid LeftTurn (double angle, double speed){\n\n    Inertial.setRotation(0, degrees);\n\n    while(true){\n\n        double error = angle - Inertial.rotation();\n\n        if(fabs(error) < 1.0) break;\n\n        double correction = 0.6 * error;\n\n        if (correction > speed) correction = speed;\n        if (correction < -speed) correction = -speed;\n\n        LeftGroup.spin(forward, correction, percent);\n        RightGroup.spin(reverse, correction, percent);\n\n        wait(10, msec);\n    }\n\n    LeftGroup.stop(brake);\n    RightGroup.stop(brake);\n}\n\n// ================= OUTAKE =================\n\nvoid OutakeMiddle (double speed, double BeltSpeed, double IntakeSpeed){\n    OutakeMotor.spin(forward, speed, percent);\n    LeftIntake.spin(reverse, IntakeSpeed, percent);\n    RightIntake.spin(forward, IntakeSpeed, percent);\n    BeltAndEntry.spin(forward, BeltSpeed, percent);\n}\n\nvoid OutakeBottom (double speed, double BeltSpeed, double IntakeSpeed){\n    OutakeMotor.spin(reverse, speed, percent);\n    LeftIntake.spin(forward, IntakeSpeed, percent);\n    RightIntake.spin(reverse, IntakeSpeed, percent);\n    BeltAndEntry.spin(reverse, BeltSpeed, percent);\n}\n \nvoid OutakeHigh (double speed){\n    OutakeMotor.spin(forward, speed, percent);\n}\n\n// ================= AUTON ROUTINE =================\n\nvoid autonomous(void){\n\n DriveForward(100.0, 25);\n wait(2, seconds);\n\n RightTurn(90.0, 30);\n wait(2, seconds);\n\n DriveForward(40.0, 25);\n wait(2, seconds);\n\n Intake (50.0, 60.0);\n\n DriveForward(-30.0, 30);\n wait(2, seconds);\n\n LeftTurn(-135.0, 30);\n wait(2, seconds);\n\n DriveForward(139.0, 45);\n wait(2, seconds);\n\n OutakeMiddle (60,60,50);\n wait(2, seconds);\n\n OutakeMotor.stop();\n IntakeGroup.stop();\n BeltAndEntry.stop();\n}\n\n// ================= DRIVER CONTROL =================\ncontroller Controller1;\nvoid usercontrol(void){\n\n    while(true){\n\n        int forwardPower = Controller1.Axis3.position();\n        int turnPower    = Controller1.Axis1.position();\n\n        int leftPower  = forwardPower + turnPower;\n        int rightPower = forwardPower - turnPower;\n\n        LeftGroup.spin(forward, leftPower, percent);\n        RightGroup.spin(forward, rightPower, percent);\n\n        wait(20,msec);\n\n        if(Controller1.ButtonL1.pressing()){\n          IntakeGroup.spin(reverse, 50, percent);\n          BeltAndEntry.spin(reverse, 60, percent);\n  \n        }\n        else{\n          IntakeGroup.stop();\n        }\n        if(Controller1.ButtonL2.pressing()){\n          IntakeGroup.spin(forward, 50, percent);\n          BeltAndEntry.spin(reverse, 60, percent);\n        }\n        else{\n          IntakeGroup.stop();\n        }\n        if(Controller1.ButtonA.pressing()){\n          OutakeMotor.spin(forward, 50, percent);\n  \n        }\n        else{\n          IntakeGroup.stop();\n    }\n        if(Controller1.ButtonB.pressing()){\n          OutakeMotor.spin(reverse, 50, percent);\n  \n        }\n        else{\n          IntakeGroup.stop();\n    }\n}\n\n// ================= MAIN =================\n\nint main(){\n\n    Inertial.calibrate();\n    while (Inertial.isCalibrating()) {\n        wait(20, msec);\n    }\n\n    Competition.autonomous(autonomous);\n    Competition.drivercontrol(usercontrol);\n\n    while(true){\n        wait(100, msec);\n    }\n}","textLanguage":"cpp","robotConfig":[],"slot":2,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.64.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}